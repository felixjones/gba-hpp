/*
===============================================================================

 Copyright (C) 2022-2023 gba-hpp contributors
 For conditions of distribution and use, see copyright notice in LICENSE.md

===============================================================================
*/

#ifndef GBAXX_TYPE_LUT_HPP
#define GBAXX_TYPE_LUT_HPP
/** @file */

#include <array>

#include <gba/type/angle.hpp>
#include <gba/type/util.hpp>

namespace gba::lut {

    /**
     * @brief Create an array using a generator function.
     *
     * This function takes a generator function and creates an array of size N using the values generated by the
     * generator. The generator function is expected to take an unsigned integer as its argument, which represents the
     * index of the element being generated. The return type of the generator function must be deducible by
     * decltype(g(std::size_t{})), and the size of the resulting array is fixed to N.
     *
     * @note This is only available in a constexpr context for the purposes of generating look-up-tables.
     *
     * @tparam N The size of the resulting array.
     * @tparam Generator The type of the generator function.
     * @param g The generator function to generate the values for the array.
     * @return An std::array with elements generated by the generator function.
     */
    template <std::size_t N, class Generator>
    consteval auto make(Generator g) -> std::array<decltype(g(std::size_t{})), N> {
        auto result = std::array<decltype(g(std::size_t{})), N>{};
        for (std::size_t ii = 0; ii < N; ++ii) {
            result[ii] = g(ii);
        }
        return result;
    }

    /**
     * @struct angle_array
     * @brief Custom std::array type that can be accessed using a binary angle measurement.
     *
     * This type is intended for accessing look-up-tables that expect an angle for the index. For example, a sine or
     * cosine look-up-table would convert an angle to a fixed-point sin or cos.
     *
     * @sa angle
     */
    template <typename T, Angle U>
    struct angle_array : public std::array<T, 1 << U::bits> {
        using angle_type = U;

        template <Angle V>
        constexpr T operator[](V i) const noexcept {
            constexpr auto mask = (1 << U::bits) - 1;

            return this->data()[shift_to<V::bits, U::bits>(i.data()) & mask];
        }
    };

    /**
     * @brief Create an angle_array using a generator function.
     *
     * This function takes a generator function and creates an array of size N using the values generated by the
     * generator. The generator function is expected to take an angle as its argument, which represents the angular
     * index of the element being generated. The return type of the generator function must be deducible by
     * decltype(g(T{})), and the size of the resulting array is fixed to the bit precision of the binary angle type.
     *
     * @note This is only available in a constexpr context for the purposes of generating look-up-tables.
     *
     * @tparam T The binary angle type.
     * @tparam Generator The type of the generator function.
     * @param g The generator function to generate the values for the array.
     * @return An angle_array with elements generated by the generator function.
     *
     * @sa angle_array
     */
    template <Angle T, class Generator>
    consteval auto make(Generator g) {
        constexpr auto size = 1 << T::bits;
        using result_type = decltype(g(T(), size));

        auto result = std::array<result_type, size>{};
        for (std::size_t ii = 0; ii < size; ++ii) {
            result[ii] = g(T(ii), size);
        }
        return angle_array<result_type, T>{result};
    }

} // namespace gba::lut

#endif // define GBAXX_TYPE_LUT_HPP
